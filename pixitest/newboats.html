
<html>
<head>
	<title>pixi.js example 2</title>
	<style>
		body {
			margin: 6;
			padding: 6;
			background-color: #FFFFFF;
		}
	</style>
	
	<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>

	<script src='pixi.js'></script>

</head>
<body>
  <canvas id='canvas'></canvas>

	<script>
var canvas = document.getElementById('canvas');
var renderer = PIXI.autoDetectRenderer(document.body.clientWidth-25, document.body.clientHeight-25, {view:canvas});
document.body.appendChild(renderer.view);

var stage = new PIXI.Container();
//stage.interactive = true;
//stage.click = function(){
	
	//}
	//stage
        //.on('mousedown', onDragStart2)
        //.on('touchstart', onDragStart2)
        //// events for drag end
        //.on('mouseup', onDragEnd2)
        //.on('mouseupoutside', onDragEnd2)
        //.on('touchend', onDragEnd2)
        //.on('touchendoutside', onDragEnd2)
        //// events for drag move
        //.on('mousemove', onDragMove2)
        //.on('touchmove', onDragMove2);

var texture = PIXI.Texture.fromImage('bunny.png');



stage.width = document.body.clientWidth;
stage.height = document.body.clientHeight;

var world = new PIXI.Container();
world.visible = true;
world.buttonMode = true;
world.render = true;
world.interactive = true;
world.position.x = 100;
world.position.y = 100;
world.width = 800;
world.height = 600;
world.scale = new PIXI.Point(1,1)
	world
        .on('mousedown', onDragStart2)
        .on('touchstart', onDragStart2)
        // events for drag end
        .on('mouseup', onDragEnd2)
        .on('mouseupoutside', onDragEnd2)
        .on('touchend', onDragEnd2)
        .on('touchendoutside', onDragEnd2)
        // events for drag move
        .on('mousemove', onDragMove2)
        .on('touchmove', onDragMove2);

document.addEventListener("mousewheel", mouseWheelHandler, false);
var SCALE_MIN = 0
var SCALE_MAX = 10

function mouseWheelHandler(e) {
	console.log(e)
	// cross-browser wheel delta
	var e = window.event || e;
	var delta = e.wheelDelta > 0 ? 1.1 : 0.9;
	var worldPos = {x: (e.pageX - world.x) / world.scale.x, y: (e.pageY - world.y)/world.scale.y}
	var newScale = {x: world.scale.x * delta, y: world.scale.y * delta}
	var newScreenPos = {x: (worldPos.x ) * newScale.x + world.x, y: (worldPos.y) * newScale.y + world.y}
	world.x -= (newScreenPos.x-e.pageX ) 
	world.y -= (newScreenPos.y-e.pageY ) 
	world.scale.x = newScale.x;
	world.scale.y = newScale.y;
	}

function keyboard(keyCode) {
  var key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  //The `downHandler`
  key.downHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) key.release();
      key.isDown = false; 
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener(
    "keydown", key.downHandler.bind(key), false
  );
  window.addEventListener(
    "keyup", key.upHandler.bind(key), false
  );
  return key;
}

 var left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);
      space = keyboard(32)
 
  left.press = function() {
	  world.position.x += 10
  }
  right.press = function() {
	  world.position.x -= 10
  }
	up.press = function() {
	  world.position.y += 10
  }
  down.press = function() {
	  world.position.y -= 10
  }
  space.press = function() {
	  world.position.x = 100
	  world.position.y = 100
	  world.scale = new PIXI.Point(1,1)
	  

	  }
	  
//var graphics = new PIXI.Graphics();

////for (var x = 0; x < 800; x+=5){
	////for (var y = 0; y < 600; y +=5){
		////graphics.lineStyle(0.5);
		////graphics.beginFill(0xFFFF0B, 0.5);
		////graphics.drawRect(x-0.5 ,y-0.5 ,5,5);
		////graphics.endFill();
	////}
//}

//world.addChild(graphics)

for (var i = 0; i < 1; i++)
{
    createBunny(100,100);
}


function keyturn() {
	if (left.isDown){
		left.press()}
	if (right.isDown){
		right.press()}
	if (up.isDown){
		up.press()}
	if (down.isDown){
		down.press()}	
}

	
function Boat(xinit,yinit,color,team) {
	this.color = color
	this.x=xinit;
	this.y=yinit;
	this.kills = 0;
	this.damage = 10;
	this.weprange = 50;
	this.maxfireangle = 5;
	this.health = 100
	this.xdest = null;
	this.ydest = null;
	this.speed=20;
	this.thrust=3;
	this.mass=2;
	this.heading=90;
	this.turnrate = 1
	this.dt=0.01
	this.rgb = color || [myrandint(250),myrandint(250),myrandint(250)]
	this.team = team || 1
	this.target = null
	this.graphics = new PIXI.Graphics();
	world.addChild(this.graphics)
	this.graphics.lineStyle(0)
	this.graphics.beginFill(0xFFFF0B)
	this.graphics.drawCircle(this.x,this.y,this.mass)
	this.graphics.endFill()
		
	this.updatePos=function() {
		this.x = this.x + Math.cos(this.heading * Math.PI/180) * this.speed * this.dt;
		this.y = this.y - Math.sin(this.heading * Math.PI/180) * this.speed * this.dt;
	}
	
	this.updateTargetPos=function(){
		this.setdest(this.target.x,this.target.y)
	}
	
	this.setTarget=function(tar){
		this.target = tar
		this.updateTargetPos()
	}
	
	this.distToTarget=function(){
		return Math.sqrt(Math.pow(this.x - this.xdest,2)+ Math.pow(this.y - this.ydest,2))
	}
	
	this.setdest=function(x,y){
		this.xdest = x;
		this.ydest = y;
	}
	
	this.turn=function(ctx) {
		if (this.xdest == null){ 
			lol=1;
		} else {
			if (this.y < this.ydest){
				var myvar = 180;
			} else {
				var myvar = 0;
			}
			this.bearing = (Math.atan((this.x - this.xdest) / (this.y - this.ydest )) * 180 / Math.PI)+90 + myvar;
			if (this.bearing > this.heading){
				if (this.bearing > this.heading + 180){
					this.heading -= this.turnrate
				} else {
					this.heading += this.turnrate
				}
			} else {
				if (this.heading - 180 > this.bearing){
					this.heading += this.turnrate
				} else {
					this.heading -= this.turnrate
				}
			}
					
		this.heading = this.heading % 360;
		if (this.heading <= 0) {this.heading += 360}
		
	}
}
	

	
	this.updateVel=function() {
		this.speed = this.speed * .99;
	}
	
	this.acc=function() {
		this.speed += this.thrust/this.mass;
	}
	
	this.draw=function(){
		this.graphics.moveTo(this.x,this.y)
		this.graphics.clear()
		this.graphics.lineStyle(0)
		this.graphics.beginFill(this.color)
		this.graphics.drawCircle(this.x,this.y,this.mass)
		this.graphics.endFill()
		
	}

	this.oneStep=function(){
		this.acc()
		this.updateVel();
		this.updateTargetPos()	
		this.turn(ctx);
		this.updatePos();
		this.draw();
	}
	
	this.fire=function(){
		if (this.distToTarget() < this.weprange){
			if (Math.abs(this.bearing - this.heading) < this.maxfireangle){
				this.target.health -= this.damage
				console.log("firing")
				if (this.target.health <= 0){
					this.target = null
					this.kills += 1
					console.log("kill:" + this.kills)
				}
			}
		}
	}
	
	this.oneStepFight=function(){
		this.acc()
		this.updateVel();
		this.updateTargetPos()	
		this.turn();
		this.updatePos();
		this.fire();
		this.draw();
	}
}

function createBunny(x, y) {
    var bunny = new PIXI.Sprite(texture);
    bunny.interactive = true;
    bunny.buttonMode = true;
    bunny.anchor.set(0.5);
    bunny.scale.set(1);
    bunny
        // events for drag start
        .on('mousedown', onDragStart)
        .on('touchstart', onDragStart)
        // events for drag end
        .on('mouseup', onDragEnd)
        .on('mouseupoutside', onDragEnd)
        .on('touchend', onDragEnd)
        .on('touchendoutside', onDragEnd)
        // events for drag move
        .on('mousemove', onDragMove)
        .on('touchmove', onDragMove);

    bunny.position.x = x;
    bunny.position.y = y;

    world.addChild(bunny);
}

stage.addChild(world);

requestAnimationFrame( animate );

function animate() {
    requestAnimationFrame(animate);
	keyturn()
    renderer.render(stage);
}

function onDragStart(event) {
	event.stopPropagation();
    // store a reference to the data
    // the reason for this is because of multitouch
    // we want to track the movement of this particular touch
    this.data = event.data;
    this.myclick = this.data.getLocalPosition(this)
    this.myx = this.myclick.x
    this.myy = this.myclick.y
    var newPosition = this.data.getLocalPosition(this.parent)
    this.alpha = 0.5;
    this.dragging = true;
}

function onDragStart2(event) {
	event.stopPropagation();
    this.data = event.data;
    this.myclick = this.data.getLocalPosition(this)
    this.myx = this.myclick.x
    this.myy = this.myclick.y
    var newPosition = this.data.getLocalPosition(this.parent)
    this.dragging = true;
}

function onDragEnd() {
    this.alpha = 1;
    this.dragging = false;
    this.data = null;
}

function onDragEnd2() { 
	this.alpha = 1;
    this.dragging = false;
    this.data = null;
}

function onDragMove() {
    if (this.dragging) {
        var newPosition = this.data.getLocalPosition(this.parent)
        this.position.x = Math.ceil(newPosition.x - this.myx);
        this.position.y = Math.ceil(newPosition.y - this.myy)
    }
}

function onDragMove2(){
    if (this.dragging) {
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = Math.ceil(newPosition.x - this.myx * this.scale.x);
        this.position.y = Math.ceil(newPosition.y - this.myy * this.scale.y)
    }
}

function myrandint(high){
	return Math.floor((Math.random() * high) + 1)
}

function closestTarget(targetList,boat){
	closest = null
	closest_dist = Infinity 
	for (var i = 0; i < targetList.length; i++){
		var new_dist = Math.sqrt(Math.pow(boat.x - targetList[i].x,2)+ Math.pow(boat.y - targetList[i].y,2))
		if (new_dist < closest_dist){
			closest = targetList[i]
			closest_dist = new_dist
		}
	}
	boat.setTarget(closest)
}

function twoTeams(){
	var redboats = 1000
	var blueboats = 1000
	var reds = []
	var blues = []
	//create redboats
	for (var i = 0; i < redboats; i++) { 
		reds[i] = new Boat(0,myrandint(100),[255,5,5],1);
	}
	//create blueboats
	for (var i = 0; i < blueboats; i++) { 
		blues[i] = new Boat(800,myrandint(100),[5,5,255],2);
	}
	//set initial targets
	for (var i = 0; i < blues.length; i++) {
			closestTarget(reds,blues[i])
	} 
	for (var i = 0; i < reds.length; i++) {
		closestTarget(blues,reds[i])
	} 
	var count = 0;
	//move all the boats every 50ms
	var moveInterval = setInterval(function(){
		for (var i = 0; i < blues.length; i++) {	
			blues[i].oneStepFight()
		}
		for (var i = 0; i < reds.length; i++) {	
			reds[i].oneStepFight()
		}  
		for (var i = 0; i < blues.length; i++) {	
			if (blues[i].health <= 0){
				blues.splice(i,1)
			}
		}
		for (var i = 0; i < reds.length; i++) {	
			if (reds[i].health <= 0){
				reds.splice(i,1)
			}
		}
		for (var i = 0; i < blues.length; i++) {
			closestTarget(reds,blues[i])
		} 
		for (var i = 0; i < reds.length; i++) {
			closestTarget(blues,reds[i])
		} 

		count += 1
	}, 10);
} 


function Main(){
	twoTeams()
}
Main()

	</script>
 
	</body>
</html>
